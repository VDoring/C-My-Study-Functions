AND연산(&)
둘다 1이여야만 1이된다.

1 & 1 = 1
1 & 0 = 0
0 & 1 = 0
0 & 0 = 0


OR 연산(| )
둘중 하나만 1이면 1이된다.

1 | 1 = 1
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0


XOR 연산(^)
두수가 달라야만 1이된다.

1 ^ 1 = 0
0 ^ 1 = 1
1 ^ 0 = 1
0 ^ 0 = 0


반전 연산(~)
0을 1로, 1을 0으로 바꿔준다.

~1100을 하면 0011이 된다.



<< 연산(쉬프트 연산)
비트를 왼쪽으로 쉬프트(Shift)한다.

101011 을 << 연산하면
101011  이렇게 한칸씩 밀려나게 된다.
여기서 맨 앞자리가 한칸 비었으므로 0으로 채워지면
1010110 이 된다.
이제 맨 왼쪽수가 남으므로 제거한다.(원래비트와 숫자 수가 같아야한다)
010110 이렇게 된다.



>> 연산(쉬프트 연산)
비트를 오른쪽으로 쉬프트(Shift)한다.

11100010 >> 3 하면 11111100이 된다.
(<< 연산은 0이 채워지는대 반해, >> 연산은 앞부분에 맨 왼쪽에 있었던 수가 채워지게 된다.)

00011001 >> 3 = 00000011



/* 비트계산 관련 주의할 점 */
int a = 0xAF; 는 a = 10101111; 이지만, a는 int형이기때문에
a = 00000000 00000000 00000000 10101111 이 된다.
a를 반전시키게 되면 이렇게 된다.
a = 11111111 11111111 11111111 01010000 즉 a = 0xFFFFFF50 이 된다.

/* 16진수를 2진수로 읽는 방법 */
0xAF에서 A는 10, F는 15이다.
10과 15를 이진수로 바꾼다.
1010 1111 이 될것이고, 이걸 그냥 붙이면 된다.

[답]
0xAF = 10101111